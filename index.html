<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Palette Extractor</title>
    <style>
        :root {
            --bg-color: #f0f0f0;
            --frame-color: #333333;
            --text-color: #333333;
            --button-bg: #e0e0e0;
            --button-text: #333333;
            --settings-bg: #ffffff;
            --settings-outline: #cccccc;
            --slider-track: #dddddd;
            --slider-thumb: #666666;
            --checkbox-color: #666666;
            --frame-radius: 5px;
            --button-radius: 30px;
            --settings-radius: 3px;
            --font-family: 'Monospace', monospace;
            --font-size: 14px;
            --text-align: center;
            --in-frame-ui-scale: 1;
            --number-input-bg: #ffffff;
            --number-input-outline-color: #cccccc;
            --number-input-outline-radius: 30px;
            --frame-custom-size: 400px;
            --frame-custom-min-size: 300px;

            --table-header-bg: #f5f5f5;
            --table-row-bg-odd: #ffffff;
            --table-row-bg-even: #f9f9f9;
            --table-border-color: #e0e0e0;
            --color-outline-color: #0000ff;
            --copy-btn-hover-bg: rgba(0,0,0,0.05);
            --skin-tone-result-text-color: #000000;
            --delete-button-bg: #ff4d4d;
            --delete-button-text: white;
            --delete-button-hover-bg: #cc0000;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow-y: auto;
            font-size: var(--font-size);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
        }

        .header #settings-button {
            margin-left: auto;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            flex-grow: 1;
            padding: 20px;
            box-sizing: border-box;
        }

        .left-panel-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90vmin;
            flex-shrink: 0;
        }

        .frame {
            border: 1.6px solid var(--frame-color);
            border-radius: var(--frame-radius);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            resize: both;
            aspect-ratio: 1 / 1;
            width: var(--frame-custom-size, 90vmin);
            height: var(--frame-custom-size, 90vmin);
            min-width: var(--frame-custom-min-size);
            min-height: var(--frame-custom-min-size);
            max-width: 100%;
            max-height: 90vh;
            overflow: hidden;
            cursor: default;
        }

        .frame.eyedropper-active {
            cursor: none;
        }

        .frame.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            resize: none !important;
            z-index: 9999 !important;
            background-color: var(--bg-color) !important;
        }

        #image-display {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            user-select: none;
        }

        #image-display img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .action-buttons,
        .fullscreen-bottom-left-controls {
            position: absolute;
            z-index: 10001;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 3px;
        }

        .action-buttons {
            top: 5px;
            left: 5px;
            display: flex;
            gap: 3px;
            transform: scale(var(--in-frame-ui-scale));
            transform-origin: top left;
        }

        .fullscreen-bottom-left-controls {
            bottom: 5px;
            left: 5px;
            display: none;
            transform: scale(var(--in-frame-ui-scale));
            transform-origin: bottom left;
        }

        .frame.ui-hidden .action-buttons,
        .frame.ui-hidden .fullscreen-bottom-left-controls {
            opacity: 0;
            pointer-events: none;
        }

        .frame.ui-hidden .fullscreen-bottom-left-controls #hide-ui-button {
            opacity: 1;
            pointer-events: auto;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: rgba(0, 0, 0, 0.5);
        }

        .frame.ui-hidden .fullscreen-bottom-left-controls:hover #hide-ui-button {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid black;
            color: black;
        }

        .frame.hidden {
            display: none;
        }

        .controls {
            display: flex;
            justify-content: flex-start;
            width: 100%;
            margin-top: 10px;
            flex-wrap: wrap;
            gap: 10px;
            transition: all 0.3s ease-in-out;
        }

        .controls.minimized {
            max-height: 0;
            overflow: hidden;
            padding: 0 10px;
            margin-top: 0;
            opacity: 0;
            pointer-events: none;
        }

        button {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: 1px solid var(--frame-color);
            padding: 8px 15px;
            cursor: pointer;
            font-family: var(--font-family);
            border-radius: var(--button-radius);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        button:hover {
            opacity: 0.8;
            transform: translateY(-1px);
        }

        .action-buttons button,
        .fullscreen-bottom-left-controls button {
            font-size: 11px;
            padding: 3px 6px;
            border-radius: 3px;
        }

        #settings-panel {
            background-color: var(--settings-bg);
            border: 1px solid var(--settings-outline);
            border-radius: var(--settings-radius);
            padding: 15px;
            z-index: 10002;
            max-height: 80vh;
            overflow-y: auto;
            box-sizing: border-box;
            position: fixed;
            top: 50px;
            right: 8px;
            width: 300px;
            max-width: 90vw;
            user-select: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        #settings-panel .settings-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--settings-outline);
        }
        #settings-panel .settings-panel-header h3 {
            margin: 0;
        }
        #settings-panel .settings-panel-header .header-buttons {
            display: flex;
            gap: 5px;
        }
        #settings-panel .settings-panel-header .header-buttons button {
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 5px;
            margin: 0;
        }
        
        #palette-analysis-panel {
            background-color: var(--settings-bg);
            border: 1px solid var(--settings-outline);
            border-radius: var(--settings-radius);
            padding: 0;
            z-index: 10002;
            max-height: 80vh;
            overflow: hidden;
            box-sizing: border-box;
            position: relative;
            margin-top: 20px;
            max-width: 90vw;
            display: flex;
            flex-direction: column;
            --header-height: 60px;
            user-select: none;
            font-size: var(--font-size);
        }

        #settings-panel input, #settings-panel select,
        #palette-analysis-panel input, #palette-analysis-panel select {
            user-select: text;
            font-family: var(--font-family);
            font-size: var(--font-size);
        }

        .settings-header {
            background-color: var(--settings-bg);
            padding: 15px;
            position: sticky;
            top: 0;
            z-index: 1;
            border-bottom: 1px solid var(--settings-outline);
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: var(--header-height);
            box-sizing: border-box;
            font-family: var(--font-family);
        }

        .settings-header h3 {
            margin: 0;
        }

        .settings-content-scrollable {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            max-height: calc(80vh - var(--header-height));
            box-sizing: border-box;
            font-family: var(--font-family);
        }

        .drag-handle {
            position: static;
            order: 2;
            margin-left: 10px;
            cursor: move;
            font-size: 20px;
            color: var(--settings-outline);
            z-index: 10;
            display: none;
        }

        .drag-handle:hover {
            color: var(--frame-color);
        }

        .setting-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed var(--settings-outline);
        }
        .setting-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .setting-group h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-family: var(--font-family);
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-family: var(--font-family);
        }

        input[type="color"],
        input[type="text"],
        select {
            background-color: var(--number-input-bg);
            border: 1px solid var(--number-input-outline-color);
            color: var(--text-color);
            padding: 1px;
            margin-bottom: 5px;
            width: calc(100% - 12px);
            border-radius: var(--number-input-outline-radius);
            font-family: var(--font-family);
        }

        input[type="number"] {
            background-color: var(--number-input-bg);
            color: var(--text-color);
            border: 1px solid var(--number-input-outline-color);
            border-radius: var(--number-input-outline-radius);
            padding: 3px 5px;
            box-sizing: border-box;
            width: calc(100% - 12px);
            margin-bottom: 5px;
            font-family: var(--font-family);
        }

        .slider-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
        }

        .slider-input-group label {
            margin-bottom: 0;
            flex-shrink: 0;
        }

        .slider-input-group input[type="range"] {
            flex-grow: 1;
            width: auto;
            margin-bottom: 0;
        }

        .slider-input-group input[type="number"] {
            width: 60px;
            margin-bottom: 0;
            text-align: center;
            padding: 3px;
        }

        input[type="range"] {
            width: 40%;
            -webkit-appearance: none;
            height: 3px;
            background: var(--slider-track);
            border-radius: 5px;
            margin-bottom: 10px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
        }

        input[type="checkbox"] {
            accent-color: var(--checkbox-color);
        }

        #hide-frame-ui-button,
        #swap-panels-button {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: 1px solid var(--frame-color);
            padding: 8px 15px;
            cursor: pointer;
            font-family: var(--font-family);
            border-radius: var(--button-radius);
        }

        #swap-panels-button {
            display: none;
        }

        .main-container.side-by-side-layout {
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            position: relative;
            padding: 20px;
        }

        .main-container.side-by-side-layout .left-panel-wrapper {
            flex: 1;
            min-width: 350px;
            max-width: 50vw;
            align-items: flex-start;
        }

        .main-container.side-by-side-layout .frame {
            width: var(--frame-custom-size, 70vh);
            height: var(--frame-custom-size, 70vh);
            min-height: var(--frame-custom-min-size, 400px);
            max-height: 80vh;
            min-width: var(--frame-custom-min-size, 300px);
            max-width: 100%;
        }

        .main-container.side-by-side-layout .controls {
            width: 100%;
            justify-content: flex-start;
        }

        .main-container.side-by-side-layout #palette-analysis-panel {
            flex: 1;
            min-width: 300px;
            max-width: 40vw;
            height: auto;
            max-height: 90vh;
            margin-top: 0;
            resize: both;
            transform: translate3d(0, 0, 0);
        }

        .main-container.side-by-side-layout #palette-analysis-panel .drag-handle {
            display: block !important;
        }

        .main-container.swapped .left-panel-wrapper {
            order: 2;
        }
        .main-container.swapped #palette-analysis-panel {
            order: 1;
        }

        .main-container.side-by-side-layout #swap-panels-button {
            display: inline-block;
        }

        #color-palette-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--font-size);
            table-layout: fixed;
            margin-top: 15px;
            font-family: var(--font-family);
        }

        #color-palette-table th,
        #color-palette-table td {
            border: 1px solid var(--table-border-color);
            padding: 6px 4px;
            text-align: left;
            word-break: break-all;
        }

        #color-palette-table th {
            background-color: var(--table-header-bg);
            font-weight: bold;
            text-align: center;
        }

        #color-palette-table tbody tr:nth-child(odd) {
            background-color: var(--table-row-bg-odd);
        }

        #color-palette-table tbody tr:nth-child(even) {
            background-color: var(--table-row-bg-even);
        }

        #color-palette-table th:first-child,
        #color-palette-table td:first-child {
            width: 50px; /* Wider for color sample */
        }

        #color-palette-table th:nth-child(2),
        #color-palette-table td:nth-child(2) {
            width: calc(100% - 50px - 40px); /* Adjust Hex column width */
        }


        .color-sample-cell {
            padding: 0;
            text-align: center;
            vertical-align: middle;
        }

        .color-sample {
            width: 100%;
            height: 25px; /* Make color sample taller to fit the wider cell */
            border: 1px solid var(--frame-color);
            display: inline-block;
            vertical-align: middle;
            border-radius: 2px;
            box-sizing: border-box; /* Include padding/border in the element's total width and height */
        }

        .color-code-cell .color-value {
            flex-grow: 1;
            cursor: pointer;
            padding-right: 5px;
        }
        .color-code-cell .color-value:hover {
            background-color: var(--copy-btn-hover-bg);
            border-radius: 3px;
        }

        .delete-btn {
            background-color: var(--delete-button-bg);
            color: var(--delete-button-text);
            border: none;
            padding: 3px 6px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
            width: 100%;
            box-sizing: border-box;
        }
        .delete-btn:hover {
            background-color: var(--delete-button-hover-bg);
        }


        .color-location-indicator {
            position: absolute;
            width: 1em;
            height: 1em;
            color: var(--color-outline-color);
            font-size: 1.5em;
            line-height: 1;
            text-align: center;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; /* Outline for visibility */
        }
        
        #skin-tone-analysis-section {
            margin-top: 5px;
            padding-bottom: 10px;
            border-bottom: 1px dashed var(--settings-outline);
        }
        #skin-tone-analysis-section h4 {
            margin-bottom: 5px;
        }
        #skin-tone-analysis-section p {
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 10px;
            font-family: var(--font-family);
        }
        #pick-skin-tone-button {
            width: auto;
            padding: 6px 12px;
            margin-bottom: 10px;
        }
        #skin-tone-result {
            margin-top: 15px;
            border: 1px solid var(--settings-outline);
            border-radius: 5px;
            padding: 10px;
            background-color: var(--table-row-bg-even);
            font-weight: normal;
            color: var(--skin-tone-result-text-color);
            white-space: pre-wrap;
            font-size: 13px;
            line-height: 1.6;
            font-family: var(--font-family);
        }
        #skin-tone-result strong {
            display: block;
            margin-top: 8px;
            margin-bottom: 3px;
            font-size: 14px;
            color: var(--frame-color);
        }
        #skin-tone-result strong:first-child {
            margin-top: 0;
        }

        #magnifier {
            position: fixed;
            width: 150px;
            height: 150px;
            border: 2px solid var(--frame-color);
            border-radius: 5px;
            overflow: hidden;
            z-index: 10003;
            background-color: var(--bg-color);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            display: none;
            transform: translate(-50%, -100%);
            font-family: var(--font-family);
        }

        #magnifier-canvas {
            display: block;
            width: 100%;
            height: calc(100% - 30px);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #magnifier-info {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 12px;
            text-align: center;
            padding: 2px 0;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            height: 30px;
        }
        #magnifier-info .color-display {
            width: 18px;
            height: 18px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 2px;
            flex-shrink: 0;
        }


        #magnifier-crosshair {
            position: absolute;
            top: calc(50% - 15px);
            left: calc(50% - 15px);
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: red;
            pointer-events: none;
            text-shadow: 0 0 3px black;
            font-weight: bold;
        }

        #copy-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            z-index: 99999;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            pointer-events: none;
            font-family: var(--font-family);
            font-size: 14px;
        }


        @media (max-width: 767px), (max-width: 991px) and (orientation: portrait) {
            .main-container {
                padding: 10px;
                flex-wrap: wrap;
                align-items: flex-start;
            }

            .frame {
                height: var(--frame-custom-size, 70vmin);
                width: var(--frame-custom-size, 70vmin);
            }
            .controls {
                justify-content: flex-start;
            }

            #settings-panel {
                width: 95vmin;
                max-width: 500px;
                max-height: 80vh;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                margin-top: 0;
                resize: none;
                box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            }

            #palette-analysis-panel {
                width: 95vmin;
                max-width: 500px;
                max-height: 80vh;
                position: static;
                margin-top: 20px;
                resize: none;
                transform: none;
            }

            #palette-analysis-panel .drag-handle {
                display: none !important;
            }

            .main-container.side-by-side-layout {
                flex-direction: column;
                gap: 15px;
                padding: 10px;
                align-items: center;
                justify-content: flex-start;
            }

            .main-container.side-by-side-layout .left-panel-wrapper,
            .main-container.side-by-side-layout #palette-analysis-panel {
                width: 95vw;
                max-width: 500px;
                min-width: unset;
                flex: unset;
            }

            .main-container.side-by-side-layout #palette-analysis-panel {
                resize: both;
            }

            .main-container.side-by-side-layout #palette-analysis-panel .drag-handle {
                display: block !important;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <button id="layout-button">Layout</button>
        <button id="settings-button">Settings</button>
    </div>

    <div class="main-container">
        <div class="left-panel-wrapper">
            <div class="frame">
                <div class="action-buttons">
                    <button id="fullscreen-button">Full</button>
                </div>
                <div class="fullscreen-bottom-left-controls" style="display: none;">
                    <button id="hide-ui-button">Hide</button>
                </div>
                <div id="image-display">
                    <img id="uploaded-image" src="" alt="Uploaded Image" style="display:none;">
                    <p id="placeholder-text">Upload an image to extract its color palette.</p>
                </div>
            </div>
            <div class="controls">
                <button id="upload-button">Upload Image</button>
                <button id="clear-button">Clear</button>
                <button id="analyze-button">Analyze Colors</button>
                <button id="export-button">Export Results</button>
                <button id="palette-settings-button">Palette</button>
                <button id="hide-frame-ui-button">⦸</button>
                <button id="swap-panels-button">↺</button>
            </div>
        </div>
        <div id="palette-analysis-panel" style="display: none;">
            <div class="settings-header">
                <div id="drag-handle" class="drag-handle">✥</div>
                <h3>Color Palette Analysis</h3>
            </div>
            <div class="settings-content-scrollable">
                <div class="setting-group" id="skin-tone-analysis-section">
                    <h4>Skin Tone Analysis</h4>
                    <p>Pick a color from the image that best represents your skin tone to get color recommendations. For best results, choose an area on your jawline or inner arm in natural lighting. [ This program is not accurate and merely for preview purposes ]</p>
                    <button id="pick-skin-tone-button">Pick Skin Tone</button>
                    <p id="skin-tone-result"></p>
                </div>

                <div class="setting-group">
                    <h4>Extracted Color Palette</h4>
                    <button id="pick-color-button">Pick Color</button> <table id="color-palette-table">
                        <thead>
                            <tr>
                                <th style="width:50px;">Color</th>
                                <th>Hex</th>
                                <th style="width: 40px;">DEL</th>
                            </tr>
                        </thead>
                        <tbody>
                            </tbody>
                    </table>
                    <p style="font-size:12px; opacity:0.8; margin-top:10px;">Click on a color code to copy or see its location(s) in the image.</p>
                </div>

                <div class="setting-group">
                    <h4>Palette Extraction Settings</h4>
                    <div class="slider-input-group">
                        <label for="num-colors">Number of Colors:</label>
                        <input type="range" id="num-colors" min="2" max="20" step="1" value="8">
                        <input type="number" id="num-colors-num" min="2" max="20" step="1" value="8" class="slider-value-input">
                    </div>
                    <div class="slider-input-group">
                        <label for="sample-size">Sample Density:</label>
                        <input type="range" id="sample-size" min="0.1" max="1" step="0.1" value="0.5">
                        <input type="number" id="sample-size-num" min="0.1" max="1" step="0.1" value="0.5" class="slider-value-input">
                    </div>
                    <p style="font-size:12px; opacity:0.8;">Adjusting "Sample Density" too high on large images may cause performance issues.</p>
                </div>
            </div>
        </div>
    </div>

    <div id="settings-panel" style="display: none;">
        <div class="settings-panel-header">
            <h3>General Settings</h3>
            <div class="header-buttons">
                <button id="apply-general-settings-button">Apply</button>
                <button id="reset-settings-button">Reset</button>
            </div>
        </div>
        <div class="setting-group">
            <h4>Colors</h4>
            <label>Background: <input type="color" id="bg-color" value="#f0f0f0"></label>
            <label>Frame: <input type="color" id="frame-color" value="#333333"></label>
            <label>Text: <input type="color" id="text-color" value="#333333"></label>
            <label>Button BG: <input type="color" id="button-bg" value="#e0e0e0"></label>
            <label>Button Text: <input type="color" id="button-text" value="#333333"></label>
            <label>Settings BG: <input type="color" id="settings-bg" value="#ffffff"></label>
            <label>Settings Outline: <input type="color" id="settings-outline" value="#cccccc"></label>
            <label>Slider Track: <input type="color" id="slider-track" value="#dddddd"></label>
            <label>Slider Thumb: <input type="color" id="slider-thumb" value="#666666"></label>
            <label>Checkbox: <input type="color" id="checkbox-color" value="#666666"></label>
            <label>Color Outline: <input type="color" id="color-outline-color" value="#0000ff"></label>
            <label>Table Header BG: <input type="color" id="table-header-bg" value="#f5f5f5"></label>
            <label>Table Row Odd BG: <input type="color" id="table-row-bg-odd" value="#ffffff"></label>
            <label>Table Row Even BG: <input type="color" id="table-row-bg-even" value="#f9f9f9"></label>
            <label>Table Border: <input type="color" id="table-border-color" value="#e0e0e0"></label>
            <label>Copy Hover BG: <input type="color" id="copy-btn-hover-bg" value="rgba(0,0,0,0.05)"></label>
            <label>Skin Tone Result Text: <input type="color" id="skin-tone-result-text-color" value="#000000"></label>
            <label>Delete Button BG: <input type="color" id="delete-button-bg" value="#ff4d4d"></label>
            <label>Delete Button Text: <input type="color" id="delete-button-text" value="#ffffff"></label>
            <label>Delete Button Hover BG: <input type="color" id="delete-button-hover-bg" value="#cc0000"></label>
        </div>
        <div class="setting-group">
            <h4>Input Styles</h4>
            <label>Input BG Color: <input type="color" id="number-input-bg" value="#ffffff"></label>
            <label>Input Outline Color: <input type="color" id="number-input-outline-color" value="#cccccc"></label>
            <label>Input Outline Radius: <input type="number" id="number-input-outline-radius" min="0" max="50" value="30"></label>
        </div>
        <div class="setting-group">
            <h4>Border Radius</h4>
            <label>Frame: <input type="number" id="frame-radius" min="0" max="50" value="5"></label>
            <label>Buttons: <input type="number" id="button-radius" min="0" max="50" value="30"></label>
            <label>Settings UI: <input type="number" id="settings-radius" min="0" max="50" value="3"></label>
        </div>
        <div class="setting-group">
            <h4>Font</h4>
            <label>Font Family: <select id="font-family">
                <option value="'Monospace', monospace" selected>Monospace</option>
                <option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Segoe UI</option>
                <option value="'Courier New', monospace">Courier New</option>
                <option value="'Arial', sans-serif">Arial</option>
                <option value="'Georgia', serif">Georgia</option>
                <option value="'Impact', sans-serif">Impact</option>
            </select> </label>
            <label>Font Size: <input type="number" id="font-size" min="10" max="18" value="14"></label>
        </div>
        <div class="setting-group">
            <h4>Frame Size</h4>
            <label>Custom Size (px): <input type="number" id="frame-custom-size" min="200" max="1000" value="400"></label>
            <label>Min Size (px): <input type="number" id="frame-custom-min-size" min="200" max="500" value="300"></label>
            <label>In-frame UI Scale: <input type="range" id="in-frame-ui-scale" min="0.5" max="1.5" step="0.1" value="1"></label>
        </div>
    </div>

    <input type="file" id="image-input" accept="image/*" style="display: none;">

    <canvas id="hidden-canvas" style="display:none;"></canvas>
    
    <div id="magnifier" style="display: none;">
        <canvas id="magnifier-canvas"></canvas>
        <div id="magnifier-crosshair">+</div>
        <div id="magnifier-info">
            <div class="color-display"></div>
            <span class="hex-code"></span> | <span class="rgb-code"></span>
        </div>
    </div>
    <div id="copy-notification">Copied!</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const mainContainer = document.querySelector('.main-container');
            const frame = document.querySelector('.frame');
            const imageDisplay = document.getElementById('image-display');
            const uploadedImage = document.getElementById('uploaded-image');
            const placeholderText = document.getElementById('placeholder-text');
            const settingsButton = document.getElementById('settings-button');
            const paletteSettingsButton = document.getElementById('palette-settings-button');
            const layoutButton = document.getElementById('layout-button');
            const uploadButton = document.getElementById('upload-button');
            const clearButton = document.getElementById('clear-button');
            const analyzeButton = document.getElementById('analyze-button');
            const exportButton = document.getElementById('export-button');
            const swapPanelsButton = document.getElementById('swap-panels-button');
            const applyGeneralSettingsBtn = document.getElementById('apply-general-settings-button');
            const resetSettingsBtn = document.getElementById('reset-settings-button');
            const fullscreenButton = document.getElementById('fullscreen-button');
            const hideUiButton = document.getElementById('hide-ui-button');
            const hideFrameUiButton = document.getElementById('hide-frame-ui-button');
            const settingsPanel = document.getElementById('settings-panel');
            const paletteAnalysisPanel = document.getElementById('palette-analysis-panel');
            const dragHandle = document.getElementById('drag-handle');
            const fullscreenBottomLeftControls = document.querySelector('.fullscreen-bottom-left-controls');
            const imageInput = document.getElementById('image-input');
            const hiddenCanvas = document.getElementById('hidden-canvas');
            const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });
            const paletteTableBody = document.querySelector('#color-palette-table tbody');
            const numColorsInput = document.getElementById('num-colors');
            const numColorsNumInput = document.getElementById('num-colors-num');
            const sampleSizeInput = document.getElementById('sample-size');
            const sampleSizeNumInput = document.getElementById('sample-size-num');
            const pickSkinToneButton = document.getElementById('pick-skin-tone-button');
            const skinToneResult = document.getElementById('skin-tone-result');
            const controlsDiv = document.querySelector('.controls');

            const pickColorButton = document.getElementById('pick-color-button');
            const magnifier = document.getElementById('magnifier');
            const magnifierCanvas = document.getElementById('magnifier-canvas');
            const magnifierCtx = magnifierCanvas.getContext('2d', { willReadFrequently: true });
            const magnifierInfo = document.getElementById('magnifier-info');
            const magnifierColorDisplay = magnifierInfo.querySelector('.color-display');
            const magnifierHexCode = magnifierInfo.querySelector('.hex-code');
            const magnifierRgbCode = magnifierInfo.querySelector('.rgb-code');
            const copyNotification = document.getElementById('copy-notification');

            const generalSettingsInputs = document.querySelectorAll('#settings-panel input, #settings-panel select');
            const paletteSettingsInputs = document.querySelectorAll('#palette-analysis-panel input[type="range"], #palette-analysis-panel input[type="number"]');

            let originalImage = null;
            let currentPalette = [];
            let isPalettePanelManuallyHidden = false;
            let isKeyboardOpen = false;
            let isManualLayoutEnabled = true; // Set to true by default
            let dragState = { active: false, currentX: 0, currentY: 0, initialX: 0, initialY: 0, xOffset: 0, yOffset: 0 };
            let currentSkinToneAnalysisResult = "";
            let isPickingColor = false;
            let isPickingSkinTone = false;

            const defaultSettings = {
                'bg-color': '#f0f0f0',
                'frame-color': '#333333',
                'text-color': '#333333',
                'button-bg': '#e0e0e0',
                'button-text': '#333333',
                'settings-bg': '#ffffff',
                'settings-outline': '#cccccc',
                'slider-track': '#dddddd',
                'slider-thumb': '#666666',
                'checkbox-color': '#666666',
                'frame-radius': '5',
                'button-radius': '30',
                'settings-radius': '3',
                'font-family': "'Monospace', monospace",
                'font-size': '14',
                'in-frame-ui-scale': '1',
                'number-input-bg': '#ffffff',
                'number-input-outline-color': '#cccccc',
                'number-input-outline-radius': '30',
                'frame-custom-size': '400',
                'frame-custom-min-size': '300',
                'table-header-bg': '#f5f5f5',
                'table-row-bg-odd': '#ffffff',
                'table-row-bg-even': '#f9f9f9',
                'table-border-color': '#e0e0e0',
                'color-outline-color': '#0000ff',
                'copy-btn-hover-bg': 'rgba(0,0,0,0.05)',
                'skin-tone-result-text-color': '#000000',
                'delete-button-bg': '#ff4d4d',
                'delete-button-text': '#ffffff',
                'delete-button-hover-bg': '#cc0000'
            };

            settingsButton.addEventListener('click', () => togglePanel(settingsPanel));
            paletteSettingsButton.addEventListener('click', () => togglePanel(paletteAnalysisPanel, true));
            layoutButton.addEventListener('click', toggleManualLayout);
            uploadButton.addEventListener('click', () => imageInput.click());
            imageInput.addEventListener('change', handleFileUpload);
            clearButton.addEventListener('click', () => location.reload()); 
            analyzeButton.addEventListener('click', () => {
                if (!originalImage || !originalImage.naturalWidth) {
                    alert("Please upload an image first.");
                    return;
                }
                extractColorPalette(originalImage);
                if (paletteAnalysisPanel.style.display === 'none') {
                    togglePanel(paletteAnalysisPanel, true);
                }
            });
            pickColorButton.addEventListener('click', () => toggleEyedropper(false));
            pickSkinToneButton.addEventListener('click', () => toggleEyedropper(true));
            exportButton.addEventListener('click', exportResults);
            applyGeneralSettingsBtn.addEventListener('click', applyGeneralSettings);
            resetSettingsBtn.addEventListener('click', resetSettingsToDefault);
            
            swapPanelsButton.addEventListener('click', () => mainContainer.classList.toggle('swapped'));
            
            hideFrameUiButton.addEventListener('click', () => {
                frame.classList.toggle('ui-hidden');
                controlsDiv.classList.toggle('minimized');
            });

            fullscreenButton.addEventListener('click', toggleFullscreen);
            hideUiButton.addEventListener('click', () => frame.classList.toggle('ui-hidden'));

            paletteSettingsInputs.forEach(input => {
                input.addEventListener('input', () => {
                    if (originalImage) extractColorPalette(originalImage);
                    saveSettings();
                });
            });

            document.querySelectorAll('.slider-input-group').forEach(group => {
                const slider = group.querySelector('input[type="range"]');
                const number = group.querySelector('input[type="number"]');
                if (slider && number) {
                    slider.addEventListener('input', () => number.value = slider.value);
                    number.addEventListener('input', () => slider.value = number.value);
                }
            });

            window.addEventListener('resize', checkLayout);
            document.addEventListener('click', closePanelsOnClickOutside);

            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                    const newIsKeyboardOpen = window.visualViewport.height < window.innerHeight;
                    if (newIsKeyboardOpen !== isKeyboardOpen) {
                        isKeyboardOpen = newIsKeyboardOpen;
                    }
                });
            }

            dragHandle.addEventListener('mousedown', dragStart);
            dragHandle.addEventListener('touchstart', dragStart);

            imageDisplay.addEventListener('mousemove', handleEyedropperMove);
            imageDisplay.addEventListener('touchmove', handleEyedropperMove, { passive: false });
            imageDisplay.addEventListener('mouseup', handleEyedropperConfirmSelection);
            imageDisplay.addEventListener('touchend', handleEyedropperConfirmSelection);
            imageDisplay.addEventListener('mouseleave', hideMagnifier);
            imageDisplay.addEventListener('touchcancel', hideMagnifier);


            loadSettings();
            applyGeneralSettings();
            checkLayout(); // Call checkLayout to ensure initial layout is applied

            function handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    uploadedImage.src = e.target.result;
                    uploadedImage.style.display = 'block';
                    placeholderText.style.display = 'none';
                    originalImage = uploadedImage;
                    
                    uploadedImage.onload = () => {
                        extractColorPalette(originalImage);
                        if (paletteAnalysisPanel.style.display === 'none') {
                            togglePanel(paletteAnalysisPanel, true);
                        }
                    };
                    uploadedImage.onerror = () => {
                        alert('Error: Could not load image.');
                        uploadedImage.src = '';
                        uploadedImage.style.display = 'none';
                        placeholderText.style.display = 'block';
                        originalImage = null;
                    };
                };
                reader.readAsDataURL(file);
            }

            function extractColorPalette(imgElement) {
                if (!imgElement || !imgElement.naturalWidth) {
                    paletteTableBody.innerHTML = '<tr><td colspan="3">No image loaded to extract palette.</td></tr>';
                    currentPalette = [];
                    return;
                }
                
                const numColors = parseInt(numColorsInput.value, 10);
                const sampleSize = parseFloat(sampleSizeInput.value);

                const ctx = hiddenCtx;
                const scaleFactor = Math.min(1, 1000 / Math.max(imgElement.naturalWidth, imgElement.naturalHeight));
                hiddenCanvas.width = imgElement.naturalWidth * scaleFactor;
                hiddenCanvas.height = imgElement.naturalHeight * scaleFactor;
                ctx.drawImage(imgElement, 0, 0, hiddenCanvas.width, hiddenCanvas.height);

                const imageData = ctx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
                const pixels = imageData.data;
                const pixelCount = hiddenCanvas.width * hiddenCanvas.height;

                const colors = [];
                const step = Math.max(1, Math.floor(1 / sampleSize));

                for (let i = 0; i < pixelCount; i += step) {
                    const idx = i * 4;
                    const r = pixels[idx];
                    const g = pixels[idx + 1];
                    const b = pixels[idx + 2];
                    if (typeof r === 'number' && typeof g === 'number' && typeof b === 'number') {
                        colors.push([r, g, b]);
                    }
                }

                if (colors.length === 0) {
                     paletteTableBody.innerHTML = '<tr><td colspan="3">No color data found in image.</td></tr>';
                     currentPalette = [];
                     return;
                }

                // K-means++ initialization: Select first centroid randomly, then others based on distance
                let centroids = [];
                if (colors.length > 0) {
                    centroids.push(colors[Math.floor(Math.random() * colors.length)]);
                    for (let k = 1; k < numColors; k++) {
                        let distances = [];
                        let totalDistance = 0;
                        for (const color of colors) {
                            let minDistToCentroids = Infinity;
                            for (const centroid of centroids) {
                                minDistToCentroids = Math.min(minDistToCentroids, colorDistance(color, centroid));
                            }
                            distances.push(minDistToCentroids * minDistToCentroids); // Squared distance
                            totalDistance += minDistToCentroids * minDistToCentroids;
                        }

                        // Select new centroid with probability proportional to D(x)^2
                        let r = Math.random() * totalDistance;
                        let newCentroid = null;
                        for (let i = 0; i < colors.length; i++) {
                            r -= distances[i];
                            if (r <= 0) {
                                newCentroid = colors[i];
                                break;
                            }
                        }
                        if (newCentroid) {
                            centroids.push(newCentroid);
                        } else {
                            // Fallback if no centroid is found (shouldn't happen with proper logic, but good for robustness)
                            centroids.push(colors[Math.floor(Math.random() * colors.length)]);
                        }
                    }
                }


                const maxIterations = 20;
                for (let iter = 0; iter < maxIterations; iter++) {
                    const clusters = Array.from({ length: numColors }, () => []);
                    for (const color of colors) {
                        let minDist = Infinity;
                        let bestCentroidIdx = -1;
                        for (let i = 0; i < numColors; i++) {
                            const dist = colorDistance(color, centroids[i]);
                            if (dist < minDist) {
                                minDist = dist;
                                bestCentroidIdx = i;
                            }
                        }
                        if (bestCentroidIdx !== -1) {
                            clusters[bestCentroidIdx].push(color);
                        }
                    }

                    let newCentroids = [];
                    let changed = false;
                    for (let i = 0; i < numColors; i++) {
                        if (clusters[i].length > 0) {
                            const newCentroid = calculateMeanColor(clusters[i]);
                            if (colorDistance(newCentroid, centroids[i]) > 1) {
                                changed = true;
                            }
                            newCentroids.push(newCentroid);
                        } else {
                            // If a cluster becomes empty, re-initialize its centroid
                            newCentroids.push(colors[Math.floor(Math.random() * colors.length)]);
                            changed = true;
                        }
                    }
                    centroids = newCentroids;
                    if (!changed) break;
                }

                centroids.sort((a, b) => {
                    const brightnessA = (a[0] * 299 + a[1] * 587 + a[2] * 114) / 1000;
                    const brightnessB = (b[0] * 299 + b[1] * 587 + b[2] * 114) / 1000;
                    return brightnessB - brightnessA;
                });

                currentPalette = centroids.map(rgb => {
                    const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
                    const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
                    const cmyk = rgbToCmyk(rgb[0], rgb[1], rgb[2]);
                    return { rgb: rgb, hex: hex, hsl: hsl, cmyk: cmyk };
                });

                displayPalette(currentPalette);
            }

            function displayPalette(palette) {
                paletteTableBody.innerHTML = '';

                if (palette.length === 0) {
                    paletteTableBody.innerHTML = '<tr><td colspan="3">No palette extracted.</td></tr>';
                    return;
                }

                palette.forEach((color, index) => {
                    addPaletteRow(color, index);
                });
            }

            function addPaletteRow(color) {
                const row = paletteTableBody.insertRow();
                row.dataset.colorHex = color.hex;

                const colorSampleCell = row.insertCell();
                colorSampleCell.classList.add('color-sample-cell');
                const colorSampleDiv = document.createElement('div');
                colorSampleDiv.className = 'color-sample';
                colorSampleDiv.style.backgroundColor = `rgb(${color.rgb[0]},${color.rgb[1]},${color.rgb[2]})`;
                colorSampleCell.appendChild(colorSampleDiv);

                const hexCell = row.insertCell();
                hexCell.innerHTML = `<span class="color-value">${color.hex}</span>`;
                hexCell.querySelector('.color-value').addEventListener('click', (e) => {
                    copyTextToClipboard(color.hex);
                    showColorLocation(color.rgb);
                });

                const delCell = row.insertCell();
                const delButton = document.createElement('button');
                delButton.classList.add('delete-btn');
                delButton.textContent = 'DEL';
                delButton.addEventListener('click', () => deleteColorFromPalette(color.hex, row));
                delCell.appendChild(delButton);
            }

            function deleteColorFromPalette(hexToDelete, rowToRemove) {
                currentPalette = currentPalette.filter(color => color.hex !== hexToDelete);
                rowToRemove.remove();
            }

            function copyTextToClipboard(text) {
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        showCopyNotification();
                    }).catch(err => {
                        console.error('Failed to copy using clipboard API:', err);
                        fallbackCopyTextToClipboard(text);
                    });
                } else {
                    fallbackCopyTextToClipboard(text);
                }
            }

            function fallbackCopyTextToClipboard(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        showCopyNotification();
                    } else {
                        alert('Copy failed: Your browser does not support automatic copying for local files. Please manually copy the text: ' + text);
                    }
                } catch (err) {
                    alert('Copy failed: Your browser does not support automatic copying for local files. Please manually copy the text: ' + text);
                }
                document.body.removeChild(textArea);
            }

            function showCopyNotification() {
                copyNotification.style.opacity = '1';
                clearTimeout(copyNotification._timeoutId);
                copyNotification._timeoutId = setTimeout(() => {
                    copyNotification.style.opacity = '0';
                }, 1500);
            }

            function showColorLocation(targetRgb) {
                if (!originalImage || !originalImage.naturalWidth) return;

                document.querySelectorAll('.color-location-indicator').forEach(el => el.remove());

                const imgNaturalWidth = originalImage.naturalWidth;
                const imgNaturalHeight = originalImage.naturalHeight;

                hiddenCanvas.width = imgNaturalWidth;
                hiddenCanvas.height = imgNaturalHeight;
                hiddenCtx.drawImage(originalImage, 0, 0, imgNaturalWidth, imgNaturalHeight);
                const imageData = hiddenCtx.getImageData(0, 0, imgNaturalWidth, imgNaturalHeight);
                const pixels = imageData.data;

                const tolerance = 20;
                const maxLocations = 5;
                const minDistanceBetweenIndicators = 50; 

                const matchingLocations = [];

                for (let i = 0; i < pixels.length; i += 4) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];

                    const dist = colorDistance([r, g, b], targetRgb);

                    if (dist < tolerance) {
                        const x = (i / 4) % imgNaturalWidth;
                        const y = Math.floor((i / 4) / imgNaturalWidth);

                        let tooClose = false;
                        for (const existingLoc of matchingLocations) {
                            if (Math.sqrt(Math.pow(x - existingLoc.x, 2) + Math.pow(y - existingLoc.y, 2)) < minDistanceBetweenIndicators) {
                                tooClose = true;
                                break;
                            }
                        }

                        if (!tooClose) {
                            matchingLocations.push({ x, y });
                            if (matchingLocations.length >= maxLocations) break;
                        }
                    }
                }

                if (matchingLocations.length === 0 && pixels.length > 0) {
                    let closestDist = Infinity;
                    let closestLoc = null;
                    const sampleStep = Math.max(1, Math.floor(pixels.length / (4 * 5000)));
                    for (let i = 0; i < pixels.length; i += 4 * sampleStep) {
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        const dist = colorDistance([r, g, b], targetRgb);
                        if (dist < closestDist) {
                            closestDist = dist;
                            const x = (i / 4) % imgNaturalWidth;
                            const y = Math.floor((i / 4) / imgNaturalWidth);
                            closestLoc = { x, y };
                        }
                    }
                    if (closestLoc) {
                         matchingLocations.push(closestLoc);
                    }
                }

                const imgRect = uploadedImage.getBoundingClientRect();
                const displayWidth = imgRect.width;
                const displayHeight = imgRect.height;

                const naturalWidth = originalImage.naturalWidth;
                const naturalHeight = originalImage.naturalHeight;

                let actualImageDisplayWidth, actualImageDisplayHeight;
                let displayOffsetX, displayOffsetY;

                const aspectRatioNatural = naturalWidth / naturalHeight;
                const aspectRatioDisplay = displayWidth / displayHeight;

                if (aspectRatioDisplay > aspectRatioNatural) {
                    actualImageDisplayHeight = displayHeight;
                    actualImageDisplayWidth = displayHeight * aspectRatioNatural;
                    displayOffsetX = (displayWidth - actualImageDisplayWidth) / 2;
                    displayOffsetY = 0;
                } else {
                    actualImageDisplayWidth = displayWidth;
                    actualImageDisplayHeight = displayWidth / aspectRatioNatural;
                    displayOffsetX = 0;
                    displayOffsetY = (displayHeight - actualImageDisplayHeight) / 2;
                }

                const scaleX = actualImageDisplayWidth / naturalWidth;
                const scaleY = actualImageDisplayHeight / naturalHeight;

                const frameRect = imageDisplay.getBoundingClientRect();

                matchingLocations.forEach(loc => {
                    const indicator = document.createElement('div');
                    indicator.classList.add('color-location-indicator');
                    indicator.textContent = '•';

                    // Calculate position relative to the image display element
                    const indicatorX = imgRect.left + displayOffsetX + (loc.x * scaleX);
                    const indicatorY = imgRect.top + displayOffsetY + (loc.y * scaleY);
                    
                    indicator.style.left = `${indicatorX}px`;
                    indicator.style.top = `${indicatorY}px`;
                    
                    document.body.appendChild(indicator); 
                });
            }

            function getSkinToneUndertone(rgb) {
                const [r, g, b] = rgb;
                let undertone = '';
                let explanation = '';

                // Calculate ratios to determine dominant hues
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const avg = (r + g + b) / 3;

                // Simple check for perceived warmth/coolness based on red/blue dominance
                // This is a more robust approach than simple direct comparisons
                if (r > g && r > b) {
                    // Reddish dominant, likely warm or neutral-warm
                    if (g > b) { // More green than blue, leaning yellow/peach
                        undertone = 'Warm (Golden/Peach)';
                        explanation = "Your skin has a noticeable golden or peachy hue, indicating warm undertones. You'll glow in rich, earthy tones.";
                    } else { // More blue than green, might be rosy/neutral
                        if (Math.abs(r - b) < 25 && Math.abs(r - g) < 25) {
                            undertone = 'Neutral';
                            explanation = "Your skin has a balanced mix of warm and cool tones, allowing you to wear a wide range of colors beautifully.";
                        } else {
                            undertone = 'Cool (Rosy/Pink)'; // Strong red, but not necessarily yellow-dominant
                            explanation = "Your skin has a rosy or pinkish tint, indicating cool undertones. Jewel tones and cool shades will enhance your natural radiance.";
                        }
                    }
                } else if (b > r && b > g) {
                    // Bluish dominant, likely cool
                    undertone = 'Cool (Blue/Pink)';
                    explanation = "Your skin has a blue or pinkish tint, indicating cool undertones. Colors with blue or purple bases will be particularly flattering.";
                } else if (g > r && g > b) {
                    // Greenish dominant (less common for primary skin tone, but indicates olive)
                    if (Math.abs(r - g) < 20 && Math.abs(g - b) < 20) {
                         undertone = 'Neutral';
                         explanation = "Your skin has a balanced mix of warm and cool tones, allowing you to wear a wide range of colors beautifully.";
                    } else {
                        undertone = 'Olive (Greenish-Neutral)';
                        explanation = "Your skin has a unique olive or greenish undertone, suggesting a blend of warm and cool. Earthy and muted jewel tones will complement you best.";
                    }
                } else {
                    // More balanced, or hard to classify, likely neutral or a mix
                    if (Math.abs(r - g) < 20 && Math.abs(g - b) < 20) {
                        undertone = 'Neutral';
                        explanation = "Your skin has a balanced mix of warm and cool tones, allowing you to wear a wide range of colors beautifully.";
                    } else {
                        undertone = 'Neutral to Warm (Balanced/Slightly Golden)';
                        explanation = "Your skin has a balanced or slightly warm undertone. Most colors will suit you, but soft, muted, and slightly warm tones might be particularly harmonious.";
                    }
                }

                // Add a more direct check for olive based on green cast
                if (g > r && g > b && g > (r + b) / 2 + 10) { // Green is significantly higher than average of R and B
                    undertone = 'Olive (Greenish-Neutral)';
                    explanation = "Your skin has a unique olive or greenish undertone, suggesting a blend of warm and cool. Earthy and muted jewel tones will complement you best.";
                }

                return { undertone, explanation };
            }


            function analyzeSkinTone(selectedRgb) {
                if (!selectedRgb) {
                    skinToneResult.innerHTML = "Please pick your skin color from the image first.";
                    currentSkinToneAnalysisResult = "";
                    return;
                }

                const [r, g, b] = selectedRgb;
                const { undertone, explanation: undertoneExplanation } = getSkinToneUndertone(selectedRgb);

                let suitableColors = [];
                let colorTemperature = ''; // Derive temperature from undertone for consistency

                switch (undertone) {
                    case 'Warm (Golden/Peach)':
                        colorTemperature = 'Warm';
                        suitableColors = ['Earth Tones (Olive Green, Mustard, Terracotta)', 'Warm Reds (Coral, Rust)', 'Deep Greens', 'Warm Blues (Teal, Turquoise)', 'Gold, Bronze, Copper', 'Cream, Ivory'];
                        break;
                    case 'Cool (Blue/Pink)':
                    case 'Cool (Rosy/Pink)':
                        colorTemperature = 'Cool';
                        suitableColors = ['Cool Blues (Navy, Sky Blue, Cobalt)', 'Emerald Greens', 'Cool Reds (Berry, Wine, Fuchsia)', 'Pinks, Purples', 'Silver, Platinum, White', 'True Greys'];
                        break;
                    case 'Neutral':
                        colorTemperature = 'Neutral';
                        suitableColors = ['Almost any color!', 'Soft Neutrals (Greys, Taupes, Mushroom)', 'Medium Pinks and Blues', 'Dusty Rose, Muted Peach', 'Jade Green, Lavender'];
                        break;
                    case 'Olive (Greenish-Neutral)':
                        colorTemperature = 'Neutral-Warm';
                        suitableColors = ['Muted Greens (Sage, Moss)', 'Deep Plums, Berry Tones', 'Warm Browns, Khaki', 'Teal, Turquoise', 'Gold, Bronze'];
                        break;
                    case 'Neutral to Warm (Balanced/Slightly Golden)':
                        colorTemperature = 'Neutral-Warm';
                        suitableColors = ['Soft Earth Tones', 'Muted Jewels', 'Cream, Taupe', 'Navy, Forest Green', 'Coral, Terracotta'];
                        break;
                    default:
                        colorTemperature = 'Undetermined';
                        suitableColors = ['Explore a variety of shades!'];
                }

                const skinHSL = rgbToHsl(r, g, b);
                let suggestedContrast = '';
                if (skinHSL.l > 70) {
                    suggestedContrast = 'For lighter skin tones, opting for darker, richer colors will create a beautiful contrast and make your features pop.';
                } else if (skinHSL.l < 30) {
                    suggestedContrast = 'On darker skin tones, vibrant and lighter colors often stand out beautifully, while deep tones can add a sense of rich elegance.';
                } else {
                    suggestedContrast = 'Medium skin tones are versatile. Consider experimenting with both lighter and darker shades to find the most dynamic contrasts that enhance your natural glow.';
                }

                currentSkinToneAnalysisResult = `Selected Color: ${rgbToHex(r,g,b)} (RGB: ${r}, ${g}, ${b})\n\n`;
                currentSkinToneAnalysisResult += `<strong>Color Temperature:</strong> ${colorTemperature}\n`;
                currentSkinToneAnalysisResult += `<strong>Likely Undertone:</strong> ${undertone}\n\n`;
                currentSkinToneAnalysisResult += `<strong>Recommended Colors:</strong> ${suitableColors.join(', ')}\n\n`;
                currentSkinToneAnalysisResult += `<strong>Color Theory Insights:</strong>\n`;
                currentSkinToneAnalysisResult += `${undertoneExplanation}\n`;
                currentSkinToneAnalysisResult += `${suggestedContrast}`;

                skinToneResult.innerHTML = currentSkinToneAnalysisResult.replace(/\n/g, '<br>');
            }

            function exportResults() {
                let exportContent = `Color Palette Extraction Results\n`;
                exportContent += `Date: ${new Date().toLocaleString()}\n\n`;
                exportContent += `--- Extracted Color Palette ---\n`;
                if (currentPalette.length > 0) {
                    currentPalette.forEach((color, index) => {
                        exportContent += `Color ${index + 1}:\n`;
                        exportContent += `  Hex: ${color.hex}\n`;
                        exportContent += `  RGB: ${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]}\n\n`;
                    });
                } else {
                    exportContent += `No color palette extracted yet.\n\n`;
                }
                
                exportContent += currentSkinToneAnalysisResult + "\n";

                const blob = new Blob([exportContent], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'color_palette_results.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }

            function applyGeneralSettings() {
                const root = document.documentElement;
                generalSettingsInputs.forEach(input => {
                    const variableName = '--' + input.id;
                    let value = input.value;
                    if (input.type === 'number' && !input.id.includes('in-frame-ui-scale')) {
                        value += 'px';
                    }
                    root.style.setProperty(variableName, value);
                });
                saveSettings();
            }

            function resetSettingsToDefault() {
                const root = document.documentElement;
                for (const id in defaultSettings) {
                    const value = defaultSettings[id];
                    const input = document.getElementById(id);
                    if (input) {
                        if (input.type === 'checkbox') {
                            input.checked = (value === 'true');
                        } else {
                            input.value = value;
                        }
                        let cssValue = value;
                        if (input.type === 'number' && !id.includes('in-frame-ui-scale')) {
                            cssValue += 'px';
                        }
                        root.style.setProperty('--' + id, cssValue);
                    }
                }
                saveSettings();
            }

            function saveSettings() {
                const settings = {};
                document.querySelectorAll('input, select').forEach(el => {
                    if (el.id) settings[el.id] = el.type === 'checkbox' ? el.checked : el.value;
                });
                localStorage.setItem('colorPaletteExtractorSettings', JSON.stringify(settings));
                // Do not save isManualLayoutEnabled or mainContainerLayoutClass,
                // as we want it to default to true and side-by-side always.
            }

            function loadSettings() {
                const settings = JSON.parse(localStorage.getItem('colorPaletteExtractorSettings'));
                if (settings) {
                    document.querySelectorAll('input, select').forEach(el => {
                        if (el.id && settings[el.id] !== undefined) {
                            if (el.type === 'checkbox') el.checked = settings[el.id];
                            else el.value = settings[el.id];
                        }
                    });
                }

                // Force side-by-side layout on load
                isManualLayoutEnabled = true; 
                mainContainer.classList.add('side-by-side-layout');
                paletteAnalysisPanel.style.display = 'block';
                isPalettePanelManuallyHidden = false; // Ensure panel is shown
                updateLayoutButtonText();
            }

            function togglePanel(panelToToggle, forceShow = false) {
                if (panelToToggle === settingsPanel) {
                    if (settingsPanel.style.display === 'block' && !forceShow) {
                        settingsPanel.style.display = 'none';
                    } else {
                        settingsPanel.style.display = 'block';
                    }
                } else if (panelToToggle === paletteAnalysisPanel) {
                    // In side-by-side, palette panel is always 'on' by default now.
                    // This toggle now handles manually hiding/showing it within side-by-side.
                    if (mainContainer.classList.contains('side-by-side-layout')) {
                        if (forceShow) {
                            paletteAnalysisPanel.style.display = 'block';
                            isPalettePanelManuallyHidden = false;
                        } else {
                            if (paletteAnalysisPanel.style.display === 'block') {
                                paletteAnalysisPanel.style.display = 'none';
                                isPalettePanelManuallyHidden = true;
                            } else {
                                paletteAnalysisPanel.style.display = 'block';
                                isPalettePanelManuallyHidden = false;
                            }
                        }
                    } else { // Stacked layout behavior
                        if (paletteAnalysisPanel.style.display === 'block' && !forceShow) {
                            paletteAnalysisPanel.style.display = 'none';
                            isPalettePanelManuallyHidden = true;
                        } else {
                            paletteAnalysisPanel.style.display = 'block';
                            isPalettePanelManuallyHidden = false;
                        }
                    }
                }
            }


            function closePanelsOnClickOutside(event) {
                if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') || isKeyboardOpen) {
                    return;
                }

                if (settingsPanel.style.display === 'block' && !settingsPanel.contains(event.target) && event.target !== settingsButton) {
                    settingsPanel.style.display = 'none';
                }
                
                // Only auto-hide palette analysis panel if NOT in side-by-side layout
                if (!mainContainer.classList.contains('side-by-side-layout') &&
                    paletteAnalysisPanel.style.display === 'block' &&
                    !paletteAnalysisPanel.contains(event.target) &&
                    event.target !== paletteSettingsButton &&
                    event.target !== analyzeButton &&
                    event.target !== pickColorButton &&
                    event.target !== pickSkinToneButton
                ) {
                    paletteAnalysisPanel.style.display = 'none';
                    isPalettePanelManuallyHidden = true;
                }
            }

            function toggleManualLayout() {
                isManualLayoutEnabled = !isManualLayoutEnabled;
                if (isManualLayoutEnabled) {
                    mainContainer.classList.add('side-by-side-layout');
                    paletteAnalysisPanel.style.display = 'block';
                    paletteAnalysisPanel.style.transform = 'translate3d(0, 0, 0)';
                    dragState.xOffset = 0;
                    dragState.yOffset = 0;
                    isPalettePanelManuallyHidden = false;
                } else {
                    mainContainer.classList.remove('side-by-side-layout');
                    // In stacked layout, hide if not explicitly kept open
                    if (paletteAnalysisPanel.style.display === 'block' && !isKeyboardOpen) {
                         paletteAnalysisPanel.style.display = 'none';
                         isPalettePanelManuallyHidden = true;
                    }
                    paletteAnalysisPanel.style.transform = 'none';
                    dragState.xOffset = 0;
                    dragState.yOffset = 0;
                }
                // Removed saveLayoutState() as layout should always default to side-by-side
                updateLayoutButtonText();
            }

            function updateLayoutButtonText() {
                layoutButton.textContent = isManualLayoutEnabled ? 'Layout: Side-by-Side' : 'Layout: Stacked';
            }

            function checkLayout() {
                // If manual layout is enabled (which it now is by default)
                if (isManualLayoutEnabled) {
                    mainContainer.classList.add('side-by-side-layout');
                    if (!isPalettePanelManuallyHidden) {
                        paletteAnalysisPanel.style.display = 'block';
                    }
                    updateLayoutButtonText();
                    return;
                }

                // Fallback to responsive if manual layout somehow gets disabled (unlikely with current setup)
                const shouldBeSideBySideBasedOnViewport = window.innerWidth >= 992 || (window.innerWidth >= 768 && window.matchMedia("(orientation: landscape)").matches);

                if (shouldBeSideBySideBasedOnViewport) {
                    mainContainer.classList.add('side-by-side-layout');
                    if (!isPalettePanelManuallyHidden) {
                        paletteAnalysisPanel.style.display = 'block';
                    }
                } else {
                    mainContainer.classList.remove('side-by-side-layout');
                    if (paletteAnalysisPanel.style.display === 'block' && !isKeyboardOpen) {
                         paletteAnalysisPanel.style.display = 'none';
                         isPalettePanelManuallyHidden = true;
                        
                    }
                }
                if (!mainContainer.classList.contains('side-by-side-layout')) {
                    paletteAnalysisPanel.style.transform = 'none';
                    dragState.xOffset = 0;
                    dragState.yOffset = 0;
                }
                updateLayoutButtonText();
            }

            function toggleFullscreen() {
                const isFullscreen = frame.classList.toggle('fullscreen-active');
                
                if (isFullscreen) {
                    frame._originalParent = frame.parentNode;
                    frame._originalNextSibling = frame.nextSibling;
                    frame._originalPosition = frame.style.position || '';
                    frame._originalZIndex = frame.style.zIndex || '';
                    
                    document.body.appendChild(frame);
                    
                    frame.style.position = 'fixed';
                    frame.style.zIndex = '9999';
                    frame.style.top = '0';
                    frame.style.left = '0';
                    frame.style.width = '100vw';
                    frame.style.height = '100vh';
                    frame.style.margin = '0';
                    frame.style.padding = '0';
                    frame.style.border = 'none';
                    frame.style.resize = 'none';
                    
                    imageDisplay.style.width = '100%';
                    imageDisplay.style.height = '100%';
                    imageDisplay.style.overflow = 'hidden';
                } else {
                    if (frame._originalParent) {
                        if (frame._originalNextSibling) {
                            frame._originalParent.insertBefore(frame, frame._originalNextSibling);
                        } else {
                            frame._originalParent.appendChild(frame);
                        }
                    }
                    
                    frame.style.position = frame._originalPosition;
                    frame.style.zIndex = frame._originalZIndex;
                    frame.style.top = '';
                    frame.style.left = '';
                    frame.style.width = '';
                    frame.style.height = '';
                    frame.style.margin = '';
                    frame.style.padding = '';
                    frame.style.border = '';
                    frame.style.resize = '';
                    
                    imageDisplay.style.width = '';
                    imageDisplay.style.height = '';
                    imageDisplay.style.overflow = '';
                }
                
                fullscreenButton.textContent = isFullscreen ? 'Exit' : 'Full';
                fullscreenBottomLeftControls.style.display = isFullscreen ? 'flex' : 'none';
                settingsPanel.style.display = 'none';
                if (!mainContainer.classList.contains('side-by-side-layout')) {
                    paletteAnalysisPanel.style.display = 'none';
                    isPalettePanelManuallyHidden = true;
                }
                document.querySelectorAll('.color-location-indicator').forEach(el => el.remove());
                applyGeneralSettings();
            }
            
            function getTranslateXY(elm) {
                const style = window.getComputedStyle(elm);
                const matrix = new DOMMatrixReadOnly(style.transform);
                return { x: matrix.m41, y: matrix.m42 };
            }

            function dragStart(e) {
                if (!mainContainer.classList.contains('side-by-side-layout') || paletteAnalysisPanel.style.display === 'none') return;

                const currentTransform = getTranslateXY(paletteAnalysisPanel);
                dragState.xOffset = currentTransform.x;
                dragState.yOffset = currentTransform.y;

                dragState.initialX = e.type === 'touchstart' ? e.touches[0].clientX - dragState.xOffset : e.clientX - dragState.xOffset;
                dragState.initialY = e.type === 'touchstart' ? e.touches[0].clientY - dragState.yOffset : e.clientY - dragState.yOffset;

                if (e.target === dragHandle) {
                    dragState.active = true;
                    document.body.style.userSelect = 'none';
                    document.body.style.cursor = 'grabbing';
                    document.addEventListener('mouseup', dragEnd);
                    document.addEventListener('touchend', dragEnd);
                    document.addEventListener('mousemove', drag);
                    document.addEventListener('touchmove', drag);
                }
            }
            
            function dragEnd(e) {
                dragState.initialX = dragState.currentX;
                dragState.initialY = dragState.currentY;
                dragState.active = false;
                document.body.style.userSelect = '';
                document.body.style.cursor = '';
                document.removeEventListener('mouseup', dragEnd);
                document.removeEventListener('touchend', dragEnd);
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
            }
            
            function drag(e) {
                if (dragState.active) {
                    e.preventDefault();
                    let clientX, clientY;
                    if (e.type === 'touchmove') {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    dragState.currentX = clientX - dragState.initialX;
                    dragState.currentY = clientY - dragState.initialY;

                    paletteAnalysisPanel.style.transform = `translate3d(${dragState.currentX}px, ${dragState.currentY}px, 0)`;
                }
            }

            function toggleEyedropper(forSkinTone) {
                if (!originalImage || !originalImage.naturalWidth) {
                    alert("Please upload an image first to use the color picker.");
                    return;
                }

                if (forSkinTone) {
                    isPickingSkinTone = !isPickingSkinTone;
                    isPickingColor = false;
                    pickColorButton.textContent = "Pick Color";
                } else {
                    isPickingColor = !isPickingColor;
                    isPickingSkinTone = false;
                    pickSkinToneButton.textContent = "Pick Skin Tone";
                }

                if (isPickingColor || isPickingSkinTone) {
                    if (isPickingColor) pickColorButton.textContent = "Exit Pick";
                    if (isPickingSkinTone) pickSkinToneButton.textContent = "Exit Pick";

                    frame.classList.add('eyedropper-active');
                    imageDisplay.style.pointerEvents = 'auto';
                    hiddenCanvas.width = originalImage.naturalWidth;
                    hiddenCanvas.height = originalImage.naturalHeight;
                    hiddenCtx.drawImage(originalImage, 0, 0);
                    magnifier.style.display = 'block';
                } else {
                    pickColorButton.textContent = "Pick Color";
                    pickSkinToneButton.textContent = "Pick Skin Tone";
                    frame.classList.remove('eyedropper-active');
                    magnifier.style.display = 'none';
                    hideMagnifier();
                    document.querySelectorAll('.color-location-indicator').forEach(el => el.remove());
                }
            }

            function handleEyedropperMove(e) {
                if (!(isPickingColor || isPickingSkinTone) || !originalImage || !originalImage.naturalWidth) return;

                e.preventDefault();

                let clientX, clientY;
                if (e.type.startsWith('touch')) {
                    if (e.touches.length === 0) return;
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                const imgRect = uploadedImage.getBoundingClientRect();
                
                let imgX = clientX - imgRect.left;
                let imgY = clientY - imgRect.top;

                const imgNaturalWidth = originalImage.naturalWidth;
                const imgNaturalHeight = originalImage.naturalHeight;
                const imgAspectRatio = imgNaturalWidth / imgNaturalHeight;
                const displayAspectRatio = imgRect.width / imgRect.height;

                let effectiveImgWidth, effectiveImgHeight;
                let offsetX = 0, offsetY = 0;

                if (displayAspectRatio > imgAspectRatio) {
                    effectiveImgHeight = imgRect.height;
                    effectiveImgWidth = imgRect.height * imgAspectRatio;
                    offsetX = (imgRect.width - effectiveImgWidth) / 2;
                } else {
                    effectiveImgWidth = imgRect.width;
                    effectiveImgHeight = imgRect.width / imgAspectRatio;
                    offsetY = (imgRect.height - effectiveImgHeight) / 2;
                }

                const scaledX = (imgX - offsetX) * (imgNaturalWidth / effectiveImgWidth);
                const scaledY = (imgY - offsetY) * (imgNaturalHeight / effectiveImgHeight);

                const pixelX = Math.max(0, Math.min(Math.floor(scaledX), imgNaturalWidth - 1));
                const pixelY = Math.max(0, Math.min(Math.floor(scaledY), imgNaturalHeight - 1));

                const pixelData = hiddenCtx.getImageData(pixelX, pixelY, 1, 1).data;
                const colorRgb = [pixelData[0], pixelData[1], pixelData[2]];
                const colorHex = rgbToHex(colorRgb[0], colorRgb[1], colorRgb[2]);

                magnifierColorDisplay.style.backgroundColor = `rgb(${colorRgb.join(',')})`;
                magnifierHexCode.textContent = colorHex;
                magnifierRgbCode.textContent = `RGB(${colorRgb.join(',')})`;
                magnifierInfo.style.backgroundColor = `rgba(${colorRgb.join(',')}, 0.7)`;
                magnifierInfo.style.color = getLuminance(colorRgb[0], colorRgb[1], colorRgb[2]) > 0.5 ? 'black' : 'white';


                const zoomFactor = 10;
                magnifierCanvas.width = magnifier.offsetWidth;
                magnifierCanvas.height = magnifier.offsetHeight - magnifierInfo.offsetHeight;

                magnifierCtx.imageSmoothingEnabled = false;
                magnifierCtx.clearRect(0, 0, magnifierCanvas.width, magnifierCanvas.height);

                const sourceSize = magnifierCanvas.width / zoomFactor;
                const sourceX = pixelX - sourceSize / 2;
                const sourceY = pixelY - sourceSize / 2;

                magnifierCtx.drawImage(
                    hiddenCanvas,
                    sourceX, sourceY, sourceSize, sourceSize,
                    0, 0, magnifierCanvas.width, magnifierCanvas.height
                );

                magnifier.style.left = `${clientX + 20}px`;
                magnifier.style.top = `${clientY}px`;
                magnifier.style.display = 'block';
            }

            function handleEyedropperConfirmSelection(e) {
                if (!(isPickingColor || isPickingSkinTone) || !originalImage) return;

                if (e.type === 'mouseup' && e.button !== 0) return;

                const colorHex = magnifierHexCode.textContent;
                const rgbMatch = magnifierRgbCode.textContent.match(/\d+/g);
                const colorRgb = rgbMatch ? rgbMatch.map(Number) : [0,0,0];

                const pickedColor = {
                    rgb: colorRgb,
                    hex: colorHex,
                    hsl: rgbToHsl(colorRgb[0], colorRgb[1], colorRgb[2]),
                    cmyk: rgbToCmyk(colorRgb[0], colorRgb[1], colorRgb[2])
                };

                if (isPickingColor) {
                    const isDuplicate = currentPalette.some(color => color.hex === pickedColor.hex);
                    if (!isDuplicate) {
                        currentPalette.push(pickedColor);
                        currentPalette.sort((a, b) => {
                            const brightnessA = (a.rgb[0] * 299 + a.rgb[1] * 587 + a.rgb[2] * 114) / 1000;
                            const brightnessB = (b.rgb[0] * 299 + b.rgb[1] * 587 + b.rgb[2] * 114) / 1000;
                            return brightnessB - brightnessA;
                        });
                        displayPalette(currentPalette);
                    }
                }
                
                if (isPickingSkinTone) {
                    analyzeSkinTone(colorRgb);
                }

                toggleEyedropper(false); // Turn off eyedropper after selection
            }

            function hideMagnifier() {
                magnifier.style.display = 'none';
                magnifierHexCode.textContent = '';
                magnifierRgbCode.textContent = '';
                magnifierColorDisplay.style.backgroundColor = '';
            }
            
            function rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
            }

            function rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }

                return {
                    h: h * 360,
                    s: s * 100,
                    l: l * 100
                };
            }

            function rgbToCmyk(r, g, b) {
                let c = 1 - (r / 255);
                let m = 1 - (g / 255);
                let y = 1 - (b / 255);
                let k = Math.min(c, Math.min(m, y));

                c = (c - k) / (1 - k);
                m = (m - k) / (1 - k);
                y = (y - k) / (1 - k);

                if (1 - k === 0) {
                    c = 0; m = 0; y = 0;
                } else if (isNaN(c) || isNaN(m) || isNaN(y)) {
                    c = 0; m = 0; y = 0; k = 1;
                }

                return {
                    c: c * 100,
                    m: m * 100,
                    y: y * 100,
                    k: k * 100
                };
            }

            function colorDistance(rgb1, rgb2) {
                return Math.sqrt(
                    Math.pow(rgb1[0] - rgb2[0], 2) +
                    Math.pow(rgb1[1] - rgb2[1], 2) +
                    Math.pow(rgb1[2] - rgb2[2], 2)
                );
            }

            function calculateMeanColor(colorsArray) {
                if (colorsArray.length === 0) return [0, 0, 0];
                let rSum = 0, gSum = 0, bSum = 0;
                for (const color of colorsArray) {
                    rSum += color[0];
                    gSum += color[1];
                    bSum += color[2];
                }
                return [
                    Math.round(rSum / colorsArray.length),
                    Math.round(gSum / colorsArray.length),
                    Math.round(bSum / colorsArray.length)
                ];
            }

            function getLuminance(r, g, b) {
                return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
            }
        });
    </script>
</body>
</html>
